:- module("grammar").
:- module_interface.

:- ensure_loaded("lillib/lists").
:- ensure_loaded("lillib/strings").
:- ensure_loaded("parser").
:- ensure_loaded("display").
:- ensure_loaded("types").
:- ensure_loaded("word").
:- ensure_loaded("trees").

lex_entry <- [bot] + [LEX_WORD\bot, LEX_TEMPLATE\bot].

% TYPE DECLARATIONS
% =================


:- module_implementation.

% ID SCHEMA DEFINITIONS
% =====================

% only true for lists of MAND\minus (default)
% i.e. obligatory arguments must be marked MAND\plus
only_optional <- [pred].
only_optional([]).
only_optional([X | Xs]) :-
  X = MAND\minus,
  only_optional(Xs).

% the difference from delete/3: fail if not found
find_and_delete <- [pred].
find_and_delete([X | Xs], X, Xs).
find_and_delete([X | Xs], Y, [X | Ys]) :- find_and_delete(Xs, Y, Ys).

% the difference from set_difference/3: fail if not found
find_and_delete_all <- [pred].
find_and_delete_all(X, [], X).
find_and_delete_all(X, [Y | Ys], Z) :-
  find_and_delete(X, Y, T),
  find_and_delete_all(T, Ys, Z).

% do not allow a clitic unless in clitic resolution.
assure_nocl <- [pred].
assure_nocl(plus, SYNSEM\LOCAL\CAT\CLITIC\_).
assure_nocl(_, SYNSEM\LOCAL\CAT\CLITIC\not_clitic).


% if this is a predicate candidate with scrambling possibility,
% allow either order
% others are head-first (e.g. PREP-comp, NOUN-comp)
scrambling_order <- [pred].
scrambling_order($first, $second, $head, $comp) :-
  $first = $comp,
  $second = $head.
scrambling_order($first, $second, $head, $comp) :-
  $first = $head,
  $second = $comp.

head_comp_schema_common_rule <- [pred].
head_comp_schema_common_rule($head, $comp, $mother, $clr) :-
  assure_nocl($clr, $comp),
  assure_nocl(minus, $head), % head can't ever be a clitic
  $head
    = SYNSEM\LOCAL\
      ( CAT\
        ( VAL\
          ( COMPS\$headcomps
          & AUX\[]
          & SPR\$headspr
          & MOD\$headmod
          & SUBJ\$headsubj
          )
        & CLITIC\$cl
        )
      & CONT\$cont
      ),
  $comp
    = SYNSEM\
      ( $compsynsem
      & LOCAL\CAT\VAL\
        ( SPR\$compspr
        & COMPS\$compcomps
        )
      ),
  only_optional($compcomps),
  only_optional($compspr),
  find_and_delete($headcomps, $compsynsem, $mothercomps),
  $mother
    = SYNSEM\LOCAL\
      ( CAT\
        ( VAL\
          ( COMPS\$mothercomps
          & AUX\[]
          & SPR\$headspr
          & MOD\$headmod
          & SUBJ\$headsubj
          )
        & CLITIC\$cl
        )
      & CONT\$cont
      )
    & DTRS\
      ( HEAD_DTR\$head
      & COMP_DTR\$comp
      )
  .

head_comp_schema_rule <- [pred].
head_comp_schema_rule($head, $comp, $head, $comp, $mother, $clr) :-
  head_comp_schema_common_rule($head, $comp, $mother, $clr).

comp_head_schema_rule <- [pred].
comp_head_schema_rule($comp, $head, $head, $comp, $mother, $clr) :-
  $head = SYNSEM\LOCAL\CAT\HEAD\SCRAMBLES\plus,
  head_comp_schema_common_rule($head, $comp, $mother, $clr).

% TODO change:
% if $mod contains head-left branching, branch head-left
noun_mod_order <- [pred].
noun_mod_order($left, $right, $head, $mod) :-
  $right = $head, $left = $mod.

head_mod_schema_rule <- [pred].
head_mod_schema_rule($left, $right, $head, $mod, $mother, $clr) :-
  noun_mod_order($left, $right, $head, $mod),
  assure_nocl($clr, $mod),
  assure_nocl(minus, $head), % head can't ever be a clitic
  $head
    = SYNSEM\
      ( $headsynsem
      & LOCAL\
        ( CAT\
          ( VAL\
            ( SPR\$headspec
            & AUX\[]
            & COMPS\$headcomps
            & MOD\$headmod
            & SUBJ\$headsubj
            )
          & CLITIC\$cl
          )
        & CONT\$cont
        )
      ),
  $mod
    = SYNSEM\LOCAL\CAT\VAL\
      ( SPR\$modspr
      & COMPS\$modcomps
      & MOD\[$headsynsem]
      ),
  only_optional($modcomps),
  only_optional($modspr),
  $mother
    = SYNSEM\LOCAL\
      ( CAT\
        ( VAL\
          ( SPR\$headspec
          & AUX\[]
          & COMPS\$headcomps
          & MOD\$headmod
          & SUBJ\$headsubj 
          )
        & CLITIC\$cl
        )
      & CONT\$cont
      )
    & DTRS\
      ( HEAD_DTR\$head
      & MOD_DTR\$mod
      ).

aux_other_schema_rule <- [pred].
aux_other_schema_rule($aux, $other, $aux, $other, $mother, $clr) :-
  assure_nocl($clr, $aux),
  assure_nocl(minus, $other), % other can't ever be a clitic
  $aux
    = SYNSEM\LOCAL\CAT\
      ( HEAD\$auxhead
      & VAL\
        ( AUX\$auxaux
        & SPR\$auxspr
        & MOD\$auxmod
        & SUBJ\$subj
        )
      & CLITIC\$cl
      ),
  $other
    = SYNSEM\
      ( $othersynsem
      & LOCAL\CAT\VAL\
        ( COMPS\$othercomps
        & AUX\[] % aux is always left
        & SUBJ\$subj
        )
      ),
%$aux=LEXICON\$lp,$other=LEXICON\$rp,printAVM([$lp, $rp]),
%printAVM(["O",$othersynsem]),
%printAVM(["M",$mothersynsem]),
%printAVM(["A",$auxaux]),
  member([$othersynsem, $mothersynsem], $auxaux),
%print(14),
  $mother = SYNSEM\$mothersynsem,
  $mother
    = SYNSEM\LOCAL\CAT\
      ( HEAD\$auxhead
      & VAL\
        ( COMPS\$othercomps
        & AUX\[] % aux is always left
        & SPR\$auxspr % TODO check when writing SPR rules!
        & MOD\$auxmod % TODO verify!
        & SUBJ\$subj
        )
      & CLITIC\$cl
      )
    & DTRS\
      ( AUX_DTR\$aux
      & OTHER_DTR\$other
      ).

cl_member <- [pred].
cl_member($cl, [SYNSEM\LOCAL\CAT\CLITIC\$storecl | _]) :-
  subsume($cl, $storecl),
  !.
cl_member($cl, [_ | $clstore]) :-
  cl_member($cl, $clstore).

head_cl_schema_rule <- [pred].
head_cl_schema_rule($head, $cl, $head, $cl, $mother) :-
  $head
    = SYNSEM\
      ( LOCAL\
        ( $local
        & CAT\CLITIC\not_clitic
        )
      & NONLOCAL\INHER\CLSTORE\$clstore
      ),
  $cl = SYNSEM\LOCAL\CAT\CLITIC\($cltype & is_clitic),
  \+ cl_member($cltype, $clstore), % no two clitics of same type, no order violations!
  % NONLOCAL handled in nonlocal_bind, as usual
  $mother
    = SYNSEM\LOCAL\$local
    & DTRS\
      ( HEAD_DTR\$head
      & CL_DTR\$cl
      ).

% Immediate Dominance: collects other principles
id_principle <- [pred].
id_principle(head_comp_schema, $left, $right, $head, $comp, $mother, $clr) :-
  head_comp_schema_rule($left, $right, $head, $comp, $mother, $clr).
id_principle(comp_head_schema, $left, $right, $head, $comp, $mother, $clr) :-
  comp_head_schema_rule($left, $right, $head, $comp, $mother, $clr).
id_principle(head_mod_schema, $left, $right, $head, $mod, $mother, $clr) :-
  head_mod_schema_rule($left, $right, $head, $mod, $mother, $clr).
id_principle(aux_other_schema, $left, $right, $head, $verb, $mother, $clr) :-
  aux_other_schema_rule($left, $right, $head, $verb, $mother, $clr).
id_principle(head_cl_schema, $left, $right, $head, $verb, $mother, minus) :-
  head_cl_schema_rule($left, $right, $head, $verb, $mother).

% HFP: Mother and Head share head features.
head_feature_principle <- [pred].
head_feature_principle($head, $mother) :-
  $mother = (SYNSEM\LOCAL\CAT\HEAD\$x),
  $head = (SYNSEM\LOCAL\CAT\HEAD\$x).

nonlocal_bind <- [pred].
nonlocal_bind($inher_head, $inher_nhead, $bind_head, $bind_nhead, $inher) :-
  find_and_delete_all($inher_head, $bind_nhead, $head),
  find_and_delete_all($inher_nhead, $bind_head, $nhead),
  append($head, $nhead, $inher).

cl_nonlocal_bind <- [pred].
cl_nonlocal_bind($inher_head, $inher_nhead, $bind_head, $bind_nhead, $inher) :-
  set_difference($inher_head, $bind_nhead, $head),
  set_difference($inher_nhead, $bind_head, $nhead),
  append($head, $nhead, $inher).

nonlocal_principle <- [pred].
nonlocal_principle($head, $nonhead, $mother) :-
  $head
    = SYNSEM\NONLOCAL\
      ( INHER\
        ( CLSTORE\$h_inher_cl
        )
      & TOBIND\
        ( CLSTORE\$h_bind_cl
        )
      ),
  $nonhead
    = SYNSEM\NONLOCAL\
      ( INHER\
        ( CLSTORE\$n_inher_cl
        )
      & TOBIND\
        ( CLSTORE\$n_bind_cl
        )
      ),
  $mother
    = SYNSEM\NONLOCAL\
      ( INHER\
        ( CLSTORE\$m_inher_cl
        )
      & TOBIND\
        ( CLSTORE\[]
        )
      ),
  cl_nonlocal_bind($h_inher_cl, $n_inher_cl, $h_bind_cl, $n_bind_cl, $m_inher_cl).

phonology_principle_binary <- [pred].
phonology_principle_binary($left, $right, $mother) :-
  $left = (PHONOLOGY\$leftphon & LEXICON\$leftlex),
  $right = (PHONOLOGY\$rightphon & LEXICON\$rightlex),
  $mother = (PHONOLOGY\$motherphon & LEXICON\$motherlex),
  append($leftphon, $rightphon, $motherphon),
  append($leftlex, $rightlex, $motherlex).

phonology_principle_unary <- [pred].
phonology_principle_unary($dtr, $mother) :-
  $dtr = (PHONOLOGY\$phon & LEXICON\$lex),
  $mother = (PHONOLOGY\$phon & LEXICON\$lex).

% clr = clitic resolution? (plus/minus)
principles <- [pred].
principles($schema, $left, $right, $mother, $clr) :-
  id_principle($schema, $left, $right, $head, $nonhead, $mother, $clr),
  nonlocal_principle($head, $nonhead, $mother),
  head_feature_principle($head, $mother).

default <- [pred].
default($fs, $feature, $default, $other) :-
  (follow($fs, $feature, $value),
      unifiable($value, $other),
      $value = $default, !)
    ; true.

fill_defaults <- [pred].
fill_defaults($sign) :-
  $sign
    = SYNSEM\
      ( LOCAL\CAT\
        ( $cat
        & HEAD\$head
        & VAL\$val
        )
      & NONLOCAL\
        ( INHER\$inher
        & TOBIND\$tobind
        )
      ),
  default($cat, CLITIC\, not_clitic, is_clitic),
  ($cat = CLITIC\is_clitic
    -> (default($inher, CLSTORE\, [$sign], []),
        default($tobind, CLSTORE\, [$sign], []))
    ;  (default($inher, CLSTORE\, [], [_]),
        default($tobind, CLSTORE\, [], [_]))),
  default($val, SPR\, [], [_]),
  default($val, COMPS\, [], [_]),
  default($val, MOD\, [], [_]),
  default($val, AUX\, [], [_]),
  default($inher, CLSTORE\, [], [_]),
  default($tobind, CLSTORE\, [], [_]),
  default($head, SCRAMBLES\, minus, plus),
  default($head, PREDICATE\, minus, plus).

% interface for UP
% ================

resolve_clitics <- [pred].
resolve_clitics([], $dtr, $dtr).
resolve_clitics([$cl | $clitics], $dtr, $mother) :-
  resolve_clitics($clitics, $dtr, $mother_temp),
%print("____"),
  principles(_, $cl, $mother_temp, $mother, plus).



% binary branching licence (+$schema, +$left, +$right, -$mother, -$dcp)
id_schema_binary($schema, $left, $right, $mother, $dcp) :-
      %DEBUG print(["LEFT",$left]),print(["RIGHT",$right]),
  principles($schema, $left, $right, $mother_temp, minus),
  $dcp = phonology_principle_binary($left, $right, $mother_temp),
      %DEBUG $left=LEXICON\$lp,$right=LEXICON\$rp,printAVM([$schema, $lp, $rp]),
      %DEBUG print("LEFT"),print($left),print("RIGHT"),print($right),
      %DEBUG print(["MOTHER TEMP",$mother_temp]),
 
  % TODO limit where this can happen
  $mother_temp = SYNSEM\NONLOCAL\INHER\CLSTORE\$clitics,
  resolve_clitics($clitics, $mother_temp, $mother)
      %DEBUG ,print(["MOTHER",$mother])
      %DEBUG ,print(["SCHEMA",$schema])
.

id_schema_unary(_, _, _, _) :- fail.

% translate [he runs] into [[0 1 "he"] [1 2 "runs"]]...
make_word_lattice <- [pred].
make_word_lattice([], _, []).
make_word_lattice([$word | $wordlist],
      $left,
      [left_position\$left & right_position\$right & word\$word | $lattice]) :-
  $right is $left + 1,
  make_word_lattice($wordlist, $right, $lattice).

% translate "he runs" into [[0 1 "he"] [1 2 "runs"]]...
sentence_to_word_lattice($sentence, $lattice) :-
  split($sentence, " ", $wordlist),
  make_word_lattice($wordlist, 0, $lattice).

% translates "runs" into RUNS; unifies morphological data and lexical data.
lexical_entry($word, LEX_WORD\$word & LEX_TEMPLATE\$sign) :-
  $sign = word & PHONOLOGY\[$word] & LEXICON\[$lemma],
  word_to_sign($word, $lemma, $sign),
  fill_defaults($sign).

% fetches the sign from the lexical template
lexical_entry_sign(LEX_TEMPLATE\$sign, $sign).

%ã€€Valid root sign: no unfilled dependencies
root_sign(S) :-
  S = SYNSEM\LOCAL\CAT\
      ( HEAD\PREDICATE\plus
      & VAL\
        ( SPR\$spec
        & COMPS\$comps & MOD\$mod
        )
      ),
  only_optional($spec),
  only_optional($comps),
  only_optional($mod).

reduce_sign($sign, $sign, _) :-
  % TODO not sure if this is needed / advisable
  % restriction($sign, DTRS\).
  true.

word_to_lookup_keys(_, _) :- fail.
lex_template_to_string(_, _) :- fail.
string_to_lex_template(_, _) :- fail.

parser_init :-
  set_limit_sentence_length(40),
  set_limit_edge_number(20000).

